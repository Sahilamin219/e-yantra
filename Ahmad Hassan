//You are allowed to define your own function to fulfill the requirement of tasks
//Dont change the name of following functions
#include "CB_Task_1_Sandbox.h"
/*
*
* Function Name: forward_wls
* Input: node
* Output: void
* Logic: Uses white line sensors to go forward by the number of nodes specified
* Example Call: forward_wls(2); //Goes forward by two nodes
*
*/
void forward_wls(unsigned char node, int k){
	unsigned char ls = 1, cs = 1, rs = 1, fs = 1;
	int a = 0;
	int flag=0;
	int node_count = 0;
	int tmp_node = 0;
	int isBotOnNode = 0;
	int isBotOnLine = 0;
	while (a == 0) {
		ls = ADC_Conversion(1);
		cs = ADC_Conversion(2);
		rs = ADC_Conversion(3);
		if ((ls == 0 && rs == 0 && cs == 255)) {
			forward();
			if (flag == 1) { isBotOnNode = 0; }
		}
		else if (ls == 255 && rs == 0 && cs == 255 ) {
			//velocity(25, 50);
			
			soft_left();
			printf("soft left1");
			if (flag == 1) { isBotOnNode = 0; }
			
		}
		else if (ls == 255 && rs == 0 && cs == 0) {
			//velocity(25, 50);
			soft_left();
			if (flag == 1) { isBotOnNode = 0; }
			printf("soft left2");
		}
		else if (ls == 0 && rs == 255 && cs == 255) {
			//velocity(50, 25);
			
			soft_right();
			if (flag == 1) { isBotOnNode = 0; }
			printf("soft right1");
			
		}
		else if (ls == 0 && rs == 255 && cs == 0) {
			//velocity(50, 25);
			soft_right();
			if (flag == 1) { isBotOnNode = 0; }
			printf("soft right2");
		}
		else if (ls == 255 && rs == 255 && cs == 255) {
			isBotOnNode = 1;
		}
		else if (ls == 0 && rs == 0 && cs == 0) {
			flag = 0;
			isBotOnNode = 0;
			
		}
		//if (tmp_node == 1 && (ls != 255 && rs != 255 && cs != 255)) { node_count++; }
		if (isBotOnNode == 1 && flag == 0) { node_count++; flag = 1; }
		printf("\n%d %d %d %d %d", ls, cs, rs, node_count,k);
		if (node_count == node) { stop(); break; }
		_delay_ms(1);
	}
}
void e_shape(void){
	forward_wls(1,9);
	soft_right();
	_delay_ms(1500);
	forward_wls(4,8);
	soft_left();
	_delay_ms(1000);
	forward_wls(1,7);
	soft_left();
	_delay_ms(1000);
	forward_wls(1, 6);
	soft_right();
	_delay_ms(1000);
	forward_wls(1, 5);
	soft_left();
	_delay_ms(1000);
	forward_wls(1, 4);
	soft_right();
	_delay_ms(1000);
	forward_wls(1, 3);
	soft_left();
	_delay_ms(1000);
	forward_wls(1, 2);
	soft_right();
	_delay_ms(1000);
	forward_wls(1, 1);
	soft_left();
	_delay_ms(1000);
	forward_wls(1, 1);
	soft_right();
	_delay_ms(1000);

	/*
	unsigned char ls = 1, cs = 1, rs = 1,fs = 1;
	int a=0;
	int count = 0;
	while (a == 0) {
		ls = ADC_Conversion(1);
		cs = ADC_Conversion(2);
		rs = ADC_Conversion(3);
		if((ls==0 && rs==0 && cs==255)){
			forward();
		}else if (ls == 255 && rs == 0 && cs==255) {
			velocity(25, 50);
			left();
			printf("soft left1");
		}else if (ls == 255 && rs == 0 && cs == 0) {
			velocity(25, 50);
			soft_left();
			printf("soft left2");
		}else if (ls == 0 && rs == 255 && cs == 255) {
			velocity(50, 25);
			right();
			printf("soft right1");
		}
		else if (ls == 0 && rs == 255 && cs == 0) {
			velocity(50, 25);
			soft_right();
			printf("soft right2");
		}
		else if (ls == 255 && rs == 255 && cs == 255) {
			soft_right();
			_delay_ms(50);
			break;
		}

		printf("\n%d %d %d", ls, cs, rs);
		
		//if (rs != 0 && cs != 0 && ls != 0) { break; }
		
	}
	while (a == 0) {
		ls = ADC_Conversion(1);
		cs = ADC_Conversion(2);
		rs = ADC_Conversion(3);
		if ((ls == 0 && rs == 0 && cs == 255)) {
			forward();
		}
		else if (ls == 255 && rs == 0 && cs == 255) {
			velocity(25, 50);
			left();
			printf("soft left1");
		}
		else if (ls == 255 && rs == 0 && cs == 0) {
			velocity(25, 50);
			soft_left();
			printf("soft left2");
		}
		else if (ls == 0 && rs == 255 && cs == 255) {
			velocity(50, 25);
			right();
			printf("soft right1");
		}
		else if (ls == 0 && rs == 255 && cs == 0) {
			velocity(50, 25);
			soft_right();
			printf("soft right2");
		}
		else if (ls == 255 && rs == 255 && cs == 255) {
			soft_right();
			_delay_ms(50);
			//break;
		}

		printf("\n%d %d %d", ls, cs, rs);

		//if (rs != 0 && cs != 0 && ls != 0) { break; }

	}
	*/
}

/*
*
* Function Name: left_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn left until black line is encountered
* Example Call: left_turn_wls(); //Turns right until black line is encountered
*
*/
void left_turn_wls(void) {

}

/*
*
* Function Name: right_turn_wls
* Input: void
* Output: void
* Logic: Uses white line sensors to turn right until black line is encountered
* Example Call: right_turn_wls(); //Turns right until black line is encountered
*/
void right_turn_wls(void) {

}

/*
*
* Function Name: e_shape
* Input: void
* Output: void
* Logic: Use this function to make the robot trace a e shape path on the arena
* Example Call: e_shape();
*/
/*
*
* Function Name: Task_1_1
* Input: void
* Output: void
* Logic: Use this function to encapsulate your Task 1.1 logic
* Example Call: Task_1_1();
*/
void Task_1_1(void)
{
	// Write your task 1.1 Logic here
}

/*
*
* Function Name: Task_1_2
* Input: void
* Output: void
* Logic: Use this function to encapsulate your Task 1.2 logic
* Example Call: Task_1_2();
*/
void Task_1_2(void)
{
	//write your task 1.2 logic here
}
